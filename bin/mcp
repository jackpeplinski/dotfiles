#!/usr/bin/env ruby

require 'json'
require 'open3'
require 'optparse'

class MCPCli
  def initialize
    @commands = {
      'list' => method(:list_servers),
      'tools' => method(:list_tools),
      'prompts' => method(:list_prompts),
      'resources' => method(:list_resources),
      'call' => method(:call_tool),
      'prompt' => method(:call_prompt),
      'info' => method(:show_info),
      'version' => method(:show_version)
    }
    @claude_config_path = File.expand_path('~/.claude.json')
    @mcp_config_path = nil
  end

  def run(args)
    parsed_args = parse_args(args)

    if parsed_args[:help] || parsed_args[:command].nil?
      show_help
      exit 0
    end

    @mcp_config_path = parsed_args[:mcp_config] if parsed_args[:mcp_config]
    command = parsed_args[:command]

    if @commands.key?(command)
      @commands[command].call(parsed_args[:args])
    else
      puts "Unknown command: #{command}"
      show_help
      exit 1
    end
  rescue StandardError => e
    puts "Error: #{e.message}"
    exit 1
  end

  private

  def parse_args(args)
    result = { help: false, mcp_config: nil, command: nil, args: [] }
    remaining_args = []

    i = 0
    while i < args.length
      case args[i]
      when '--help', '-h'
        result[:help] = true
        return result
      when '--mcp-config'
        if i + 1 < args.length
          result[:mcp_config] = args[i + 1]
          i += 1
        else
          raise "--mcp-config requires a path argument"
        end
      else
        remaining_args << args[i]
      end
      i += 1
    end

    unless remaining_args.empty?
      result[:command] = remaining_args[0]
      result[:args] = remaining_args[1..-1] || []
    end

    result
  end

  def show_help
    puts <<~HELP
      MCP CLI - Call MCP servers from the command line

      Usage:
        mcp_cli [--mcp-config <path>] list                                 List available MCP servers
        mcp_cli [--mcp-config <path>] tools <server_name>                  List tools available on a server
        mcp_cli [--mcp-config <path>] prompts <server_name>                List prompts available on a server
        mcp_cli [--mcp-config <path>] resources <server_name>              List resources available on a server
        mcp_cli [--mcp-config <path>] call <server_name> <tool> [args]     Call a tool on a server
        mcp_cli [--mcp-config <path>] prompt <server_name> <prompt> [args] Get a prompt from a server
        mcp_cli [--mcp-config <path>] info <server_name>                   Get detailed server information
        mcp_cli [--mcp-config <path>] version <server_name>                Get server version only

      Options:
        --mcp-config <path>  Path to MCP configuration JSON file (defaults to ~/.claude.json)

      Examples:
        mcp_cli list
        mcp_cli tools vault
        mcp_cli prompts vault
        mcp_cli resources vault
        mcp_cli call vault search_all '{"query": "example"}'
        mcp_cli prompt vault explain '{"topic": "MCP servers"}'
        mcp_cli info vault
        mcp_cli version vault
    HELP
  end

  def list_servers(_args)
    servers = load_mcp_servers

    if servers.empty?
      puts 'No MCP servers configured'
    else
      puts 'Available MCP servers:'
      servers.each do |name, config|
        cmd_display = [config['command'], *config['args']].join(' ')
        puts "  #{name}: #{cmd_display}"
      end
    end
  end

  def list_tools(args)
    if args.empty?
      puts 'Error: Server name required'
      puts 'Usage: mcp_cli tools <server_name>'
      exit 1
    end

    server_name = args[0]
    servers = load_mcp_servers
    unless servers.key?(server_name)
      puts "Error: Server '#{server_name}' not found"
      exit 1
    end

    server_info = parse_server_config(server_name, servers[server_name])

    env = ENV.to_h.merge(server_info[:env] || {})

    mcp_client = MCPClient.new(server_info[:command], server_info[:args], env)
    tools = mcp_client.list_tools

    if tools.empty?
      puts "No tools available on server '#{server_name}'"
    else
      puts "Tools available on '#{server_name}':"
      tools.each do |tool|
        puts "\n  #{tool['name']}"
        puts "    Description: #{tool['description']}" if tool['description']
        next unless tool['inputSchema'] && tool['inputSchema']['properties']

        puts '    Parameters:'
        tool['inputSchema']['properties'].each do |param, schema|
          required = tool['inputSchema']['required']&.include?(param) ? ' (required)' : ''
          puts "      - #{param}: #{schema['type']}#{required}"
          puts "        #{schema['description']}" if schema['description']
        end
      end
    end
  end

  def list_prompts(args)
    if args.empty?
      puts "Error: Server name required"
      puts "Usage: mcp_cli prompts <server_name>"
      exit 1
    end

    server_name = args[0]
    servers = load_mcp_servers
    unless servers.key?(server_name)
      puts "Error: Server '#{server_name}' not found"
      exit 1
    end

    server_info = parse_server_config(server_name, servers[server_name])

    env = ENV.to_h.merge(server_info[:env] || {})

    mcp_client = MCPClient.new(server_info[:command], server_info[:args], env)
    prompts = mcp_client.list_prompts

    if prompts.empty?
      puts "No prompts available on server '#{server_name}'"
    else
      puts "Prompts available on '#{server_name}':"
      prompts.each do |prompt|
        puts "\n  #{prompt['name']}"
        puts "    Description: #{prompt['description']}" if prompt['description']
        if prompt['arguments']
          puts "    Arguments:"
          prompt['arguments'].each do |arg|
            required = arg['required'] ? ' (required)' : ''
            puts "      - #{arg['name']}#{required}"
            puts "        #{arg['description']}" if arg['description']
          end
        end
      end
    end
  end

  def list_resources(args)
    if args.empty?
      puts "Error: Server name required"
      puts "Usage: mcp_cli resources <server_name>"
      exit 1
    end

    server_name = args[0]
    servers = load_mcp_servers
    unless servers.key?(server_name)
      puts "Error: Server '#{server_name}' not found"
      exit 1
    end

    server_info = parse_server_config(server_name, servers[server_name])

    env = ENV.to_h.merge(server_info[:env] || {})

    mcp_client = MCPClient.new(server_info[:command], server_info[:args], env)
    resources = mcp_client.list_resources

    if resources.empty?
      puts "No resources available on server '#{server_name}'"
    else
      puts "Resources available on '#{server_name}':"
      resources.each do |resource|
        puts "\n  #{resource['uri']}"
        puts "    Name: #{resource['name']}" if resource['name']
        puts "    Description: #{resource['description']}" if resource['description']
        puts "    MIME type: #{resource['mimeType']}" if resource['mimeType']
      end
    end
  end

  def call_tool(args)
    if args.length < 2
      puts 'Error: Server name and tool name required'
      puts 'Usage: mcp_cli call <server_name> <tool> [arguments_json]'
      exit 1
    end

    server_name = args[0]
    tool_name = args[1]
    tool_args = args[2] ? JSON.parse(args[2]) : {}

    servers = load_mcp_servers
    unless servers.key?(server_name)
      puts "Error: Server '#{server_name}' not found"
      exit 1
    end

    server_info = parse_server_config(server_name, servers[server_name])
    env = ENV.to_h.merge(server_info[:env] || {})

    mcp_client = MCPClient.new(server_info[:command], server_info[:args], env)
    result = mcp_client.call_tool(tool_name, tool_args)

    puts JSON.pretty_generate(result)
  end

  def call_prompt(args)
    if args.length < 2
      puts 'Error: Server name and prompt name required'
      puts 'Usage: mcp_cli prompt <server_name> <prompt> [arguments_json]'
      exit 1
    end

    server_name = args[0]
    prompt_name = args[1]
    prompt_args = args[2] ? JSON.parse(args[2]) : {}

    servers = load_mcp_servers
    unless servers.key?(server_name)
      puts "Error: Server '#{server_name}' not found"
      exit 1
    end

    server_info = parse_server_config(server_name, servers[server_name])
    env = ENV.to_h.merge(server_info[:env] || {})

    mcp_client = MCPClient.new(server_info[:command], server_info[:args], env)
    result = mcp_client.get_prompt(prompt_name, prompt_args)

    puts result
  end

  def show_info(args)
    if args.empty?
      puts 'Error: Server name required'
      puts 'Usage: mcp_cli info <server_name>'
      exit 1
    end

    server_name = args[0]
    servers = load_mcp_servers
    unless servers.key?(server_name)
      puts "Error: Server '#{server_name}' not found"
      exit 1
    end

    server_config = parse_server_config(server_name, servers[server_name])
    env = ENV.to_h.merge(server_config[:env] || {})

    mcp_client = MCPClient.new(server_config[:command], server_config[:args], env)
    server_info = mcp_client.get_server_info

    puts "Server: #{server_name}"
    puts "Name: #{server_info['name']}" if server_info['name']
    puts "Version: #{server_info['version']}" if server_info['version']
    puts "Description: #{server_info['description']}" if server_info['description']

    if server_info['protocolVersion']
      puts "Protocol Version: #{server_info['protocolVersion']}"
    end

    puts "\nConfiguration:"
    puts "  Type: #{server_config[:type]}"
    puts "  Command: #{server_config[:command]}"
    if server_config[:args] && !server_config[:args].empty?
      puts "  Args:"
      server_config[:args].each do |arg|
        puts "    - #{arg}"
      end
    end
    if server_config[:env] && !server_config[:env].empty?
      puts "  Environment:"
      server_config[:env].each do |key, value|
        puts "    #{key}: #{value}"
      end
    end

    if server_info['capabilities']
      puts "\nCapabilities:"
      server_info['capabilities'].each do |cap, value|
        puts "  #{cap}: #{value.inspect}"
      end
    end
  end

  def show_version(args)
    if args.empty?
      puts 'Error: Server name required'
      puts 'Usage: mcp_cli version <server_name>'
      exit 1
    end

    server_name = args[0]
    servers = load_mcp_servers
    unless servers.key?(server_name)
      puts "Error: Server '#{server_name}' not found"
      exit 1
    end

    server_info = parse_server_config(server_name, servers[server_name])
    env = ENV.to_h.merge(server_info[:env] || {})

    mcp_client = MCPClient.new(server_info[:command], server_info[:args], env)
    server_info = mcp_client.get_server_info

    if server_info['version']
      puts server_info['version']
    else
      puts "Version information not available"
    end
  end

  def load_mcp_servers
    config_path = @mcp_config_path || @claude_config_path

    unless File.exist?(config_path)
      if @mcp_config_path
        raise "MCP configuration file not found at #{config_path}"
      else
        raise "Claude configuration file not found at #{config_path}"
      end
    end

    config = JSON.parse(File.read(config_path))
    config['mcpServers'] || {}
  end

  def parse_server_config(name, config)
    unless config['type'].nil? || config['type'] == 'stdio'
      raise "Server '#{name}' is not a stdio server (type: #{config['type']})"
    end

    {
      name: name,
      type: config['type'] || 'stdio',
      command: config['command'],
      args: config['args'] || [],
      env: config['env'] || {}
    }
  end
end

class MCPClient
  def initialize(command, args, env)
    @command = command
    @args = args || []
    @env = env
    @process = nil
    @reader_thread = nil
    @message_id = 0
    @pending_requests = {}
    @initialized = false
    @server_info = nil
  end

  def list_tools
    ensure_initialized
    response = send_request('tools/list', {})
    response['tools'] || []
  end

  def list_prompts
    ensure_initialized
    response = send_request('prompts/list', {})
    response['prompts'] || []
  end

  def list_resources
    ensure_initialized
    response = send_request('resources/list', {})
    response['resources'] || []
  end

  def call_tool(tool_name, arguments)
    ensure_initialized
    response = send_request('tools/call', {
                              name: tool_name,
                              arguments: arguments
                            })
    response['content'] || response
  end

  def get_prompt(prompt_name, arguments)
    ensure_initialized
    response = send_request('prompts/get', {
                              name: prompt_name,
                              arguments: arguments
                            })
    if response['messages']
      response['messages'].map { |msg| msg['content']['text'] || msg['content'] }.join("\n\n")
    else
      response
    end
  end

  def get_server_info
    ensure_initialized
    @server_info || {}
  end

  private

  def ensure_initialized
    return if @initialized

    start_process
    response = send_request('initialize', {
                   protocolVersion: '2024-11-05',
                   capabilities: {
                     roots: { listChanged: true },
                     sampling: {}
                   },
                   clientInfo: {
                     name: 'mcp_cli',
                     version: '1.0.0'
                   }
                 })

    @server_info = response['serverInfo'] if response['serverInfo']
    @initialized = true
  end

  def start_process
    cmd = [@command] + @args
    @stdin, @stdout, @stderr, @wait_thread = Open3.popen3(@env, *cmd)

    @reader_thread = Thread.new do
      while line = @stdout.gets
        handle_message(JSON.parse(line))
      end
    rescue StandardError => e
      puts "Reader thread error: #{e.message}"
    end
  end

  def send_request(method, params)
    message_id = next_message_id
    message = {
      jsonrpc: '2.0',
      id: message_id,
      method: method,
      params: params
    }

    @stdin.puts(JSON.generate(message))
    @stdin.flush

    wait_for_response(message_id)
  end

  def handle_message(message)
    return unless message['id'] && @pending_requests[message['id']]

    @pending_requests[message['id']][:response] = message
    @pending_requests[message['id']][:condition].signal
  end

  def wait_for_response(message_id)
    mutex = Mutex.new
    condition = ConditionVariable.new
    @pending_requests[message_id] = { condition: condition, response: nil }

    mutex.synchronize do
      condition.wait(mutex, 30)
    end

    response = @pending_requests[message_id][:response]
    @pending_requests.delete(message_id)

    if response.nil?
      raise 'Timeout waiting for response'
    elsif response['error']
      raise "MCP Error: #{response['error']['message']}"
    end

    response['result']
  end

  def next_message_id
    @message_id += 1
  end

  def cleanup
    @reader_thread&.kill
    @stdin&.close
    @stdout&.close
    @stderr&.close
    @wait_thread&.kill
  end
end

MCPCli.new.run(ARGV) if __FILE__ == $0
